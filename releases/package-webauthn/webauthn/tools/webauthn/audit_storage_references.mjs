import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, '..', '..');

const ALLOWED_COLLECTIONS = ['webauthn_credentials', 'webauthn_challenges'];
const CONFIG_KEYS = [
  'WEBAUTHN_STORAGE_COLLECTION',
  'WEBAUTHN_CREDENTIALS_COLLECTION',
  'WEBAUTHN_CHALLENGES_COLLECTION',
  'DEFAULT_CREDENTIALS_COLLECTION',
  'DEFAULT_CHALLENGES_COLLECTION',
];
const IGNORE_DIRS = new Set([
  '.git',
  'node_modules',
  'dist',
  'build',
  'coverage',
  '.pnpm-store',
  '.idea',
  '.vscode',
  'har-files',
  'prod',
  'archive',
]);
const OUTPUT_PATH = path.join(repoRoot, 'docs', 'webauthn', 'storage_audit.md');

function isBinaryBuffer(buffer) {
  return buffer.includes(0);
}

async function listFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const results = [];
  for (const entry of entries) {
    if (IGNORE_DIRS.has(entry.name)) continue;
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...(await listFiles(fullPath)));
    } else if (entry.isFile()) {
      results.push(fullPath);
    }
  }
  return results;
}

function findMatches(content, reference, matcher) {
  const matches = [];
  let match;
  while ((match = matcher.exec(content)) !== null) {
    const index = match.index;
    const linesUntil = content.slice(0, index).split(/\n/);
    const lineNumber = linesUntil.length;
    matches.push({ reference, lineNumber, match: match[0] });
  }
  return matches;
}

function describeStatus(ref) {
  if (ALLOWED_COLLECTIONS.includes(ref)) return 'correct';
  return 'unexpected';
}

async function main() {
  const files = await listFiles(repoRoot);
  const auditEntries = [];
  const collectionPattern = /\bwebauthn_(?:credentials?|challenges?|[a-z0-9]*credential[a-z0-9]*|[a-z0-9]*challenge[a-z0-9]*)\b/gi;
  const configPattern = new RegExp(`\\b(?:${CONFIG_KEYS.join('|')})\\b`, 'g');

  for (const file of files) {
    if (path.resolve(file) === OUTPUT_PATH) continue;
    const stat = await fs.stat(file);
    if (stat.size > 2_000_000) continue;
    const buffer = await fs.readFile(file);
    if (isBinaryBuffer(buffer)) continue;
    const content = buffer.toString('utf8');

    const collections = findMatches(content, 'collection', collectionPattern);
    const configs = findMatches(content, 'config', configPattern);

    for (const match of [...collections, ...configs]) {
      const relPath = path.relative(repoRoot, file);
      const key = match.match;
      const status = match.reference === 'collection' ? describeStatus(key) : 'config';
      auditEntries.push({
        file: relPath,
        line: match.lineNumber,
        reference: key,
        kind: match.reference,
        status,
      });
    }
  }

  auditEntries.sort((a, b) => {
    if (a.file === b.file) return a.line - b.line;
    return a.file.localeCompare(b.file);
  });

  const unexpected = auditEntries.filter((entry) => entry.kind === 'collection' && entry.status !== 'correct');
  const lines = [
    '# WebAuthn storage reference audit',
    '',
    'This file is generated by `tools/webauthn/audit_storage_references.mjs`.',
    'It lists all repository references to WebAuthn collection identifiers and related configuration keys.',
    '',
    '| File | Line | Reference | Kind | Status |',
    '| --- | --- | --- | --- | --- |',
    ...auditEntries.map((entry) =>
      `| ${entry.file} | ${entry.line} | ${entry.reference} | ${entry.kind} | ${entry.status} |`,
    ),
    '',
    `Found ${unexpected.length} unexpected collection reference(s).`,
  ];

  await fs.writeFile(OUTPUT_PATH, `${lines.join('\n')}\n`, 'utf8');

  if (unexpected.length > 0) {
    console.error('[ERROR] Unexpected WebAuthn collection references found:', unexpected);
    process.exit(1);
  }
}

main().catch((error) => {
  console.error('[FATAL] Storage audit failed', error);
  process.exit(1);
});
